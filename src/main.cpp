// Mostly of the part is boilerplate code GLFW + GLAD + GLM setup

// Window and OpenGL context setup was based on learnopengl.com and AI assistance

// Object generation and Collision detection code was written by Megha

// randomized object placement was generated by AI and modified by me to add collision checks


// HW4 - Modified main.cpp with three view modes
// GLAD loads modern OpenGL function pointers (needed before calling OpenGL)
#include <glad/glad.h>
// GLFW creates the window and handles input (keyboard + mouse)
#include <GLFW/glfw3.h>
// GLM: math library for vectors, matrices, and transforms
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>

#include "Shader.h"
#include "rendering/camera/Camera.h"
#include "rendering/mesh/Mesh.h"

// object headers
#include "objects/land/Land.h"
#include "objects/houses/house-1/House1.h"
#include "objects/houses/house-2/House2.h" 
#include "objects/houses/house-3/House3.h"
#include "objects/tree/Tree.h"
#include "objects/targets/Target.h"

using namespace std;

// VIEW MODES for 3 different camera perspectives
enum ViewMode {
    ORTHOGONAL_OVERHEAD = 0,
    PERSPECTIVE_OVERHEAD = 1,
    FIRST_PERSON = 2,
    // THIRD_PERSON = 3
};

// Forward declarations (keeping all your existing ones)
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void mouse_callback(GLFWwindow* window, double xpos, double ypos);
void processInput(GLFWwindow *window);
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods); // NEW
bool isPositionValid(glm::vec3 pos, const vector<glm::vec3>& existingPositions, float minDistance);
glm::vec3 getRandomPosition(mt19937& gen, uniform_real_distribution<float>& dist, 
const vector<glm::vec3>& existingPositions, float minDistance);
// bool checkCollision(glm::vec3 newPos, glm::vec3 objPos, float radius);
bool checkAllCollisions(glm::vec3 newPos);
glm::vec3 findSafeSpawnPosition();

// NEW: View mode management functions
glm::mat4 getProjectionMatrix(ViewMode mode);
glm::mat4 getViewMatrix(ViewMode mode);
void updateOverheadCamera();

// Window size (1280 x 720)
const unsigned int SCR_WIDTH = 1280;
const unsigned int SCR_HEIGHT = 720;

// Scene bounds (keeping your existing values)
const float SCENE_SIZE = 120.0f;
const float HOUSE_MIN_DISTANCE = 15.0f;
const float TREE_MIN_DISTANCE = 8.0f;
const float TARGET_MIN_DISTANCE = 4.0f;

// Camera (acts like the player in first-person)
Camera camera(glm::vec3(0.0f, 1.8f, 0.0f));
float deltaTime = 0.0f;
float lastFrame = 0.0f;

// Mouse state: track last position to compute movement offsets
float lastX = SCR_WIDTH / 2.0f;
float lastY = SCR_HEIGHT / 2.0f;
bool firstMouse = true;

// NEW: View mode state
ViewMode currentViewMode = ORTHOGONAL_OVERHEAD;
bool mKeyPressed = false;

// NEW: Overhead camera parameters
glm::vec3 overheadPosition(0.0f, 120.0f, 60.0f);  // Even higher Y position and further back for complete overhead view
glm::vec3 sceneCenter(0.0f, 0.0f, 0.0f);         // Looking at scene center
float overheadRotationAngle = 0.0f;                // For rotating view with arrow keys
float overheadDistance = 140.0f;                   // Further distance from scene center

// Instance structure for objects (keeping your exact structure)
struct Instance {
    glm::vec3 position;
    glm::vec3 scale;
    float rotation;
    glm::vec3 color1;  // Wall color for houses, trunk color for trees
    glm::vec3 color2;  // Roof color for houses, leaf color for trees
    int type;          // House type (1 or 3 only - 2 removed)
    float collisionRadius; // Collision radius for this object
};

// Global vectors used for collision checks (filled during setup)
vector<Instance> houses;
vector<Instance> trees;
vector<Instance> targets;

int main() {
    // Initialize GLFW and request an OpenGL 3.3 Core profile
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Required on macOS for core profile
#endif

    // Create the window and OpenGL context
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Meghasrivardhan - HW4", NULL, NULL);
    if (window == NULL) {
        cout << "Failed to create GLFW window" << endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    
    // Set callbacks
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetCursorPosCallback(window, mouse_callback);
    glfwSetKeyCallback(window, key_callback); // NEW: For mode switching
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL); // Start with normal cursor

    // Load OpenGL function pointers with GLAD
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        cout << "Failed to initialize GLAD" << endl;
        return -1;
    }

    // Enable depth testing so nearer objects occlude farther ones
    glEnable(GL_DEPTH_TEST);

    // Load/compile the shader program (vertex + fragment)
    Shader shader("shaders/basic.vert", "shaders/basic.frag");
    
    // Create the ground mesh (flat plane)
    Mesh landMesh = createGround();

    // Random number generation (keeping your exact setup)
    random_device rd;
    mt19937 gen(rd());
    
    uniform_real_distribution<float> housePosDistFar(-SCENE_SIZE/2 + 10, SCENE_SIZE/2 - 10);
    uniform_real_distribution<float> treePosDistMed(-SCENE_SIZE/2 + 5, SCENE_SIZE/2 - 5);
    uniform_real_distribution<float> targetPosDistNear(-SCENE_SIZE/2 + 2, SCENE_SIZE/2 - 2);
    
    uniform_real_distribution<float> scaleDist(0.8f, 1.3f);
    uniform_real_distribution<float> rotDist(0.0f, 360.0f);
    
    vector<int> availableHouseTypes = {1, 2, 3};
    uniform_int_distribution<int> houseTypeIndexDist(0, 2);

    // Track used positions to avoid placing objects too close
    vector<glm::vec3> occupiedPositions;

    // Create house instances (keeping your exact logic)
    houses.resize(8);
    vector<glm::vec3> wallColors = {
        {0.9f, 0.9f, 0.8f},   // Off-white
        {0.8f, 0.7f, 0.6f},   // Beige  
        {0.7f, 0.8f, 0.9f},   // Light blue
        {0.9f, 0.8f, 0.7f},   // Peach
        {0.6f, 0.8f, 0.6f},   // Light green
        {0.9f, 0.7f, 0.8f},   // Pink
        {0.8f, 0.8f, 0.9f},   // Lavender
        {0.9f, 0.9f, 0.7f}    // Light yellow
    };
    
    vector<glm::vec3> roofColors = {
        {0.6f, 0.3f, 0.2f},   // Dark red
        {0.4f, 0.3f, 0.2f},   // Dark brown
        {0.3f, 0.4f, 0.3f},   // Dark green
        {0.5f, 0.4f, 0.3f},   // Tan
        {0.4f, 0.4f, 0.5f},   // Dark blue
        {0.5f, 0.3f, 0.4f},   // Maroon
        {0.3f, 0.3f, 0.4f},   // Dark purple
        {0.6f, 0.5f, 0.2f}    // Golden brown
    };
    
    for (int i = 0; i < 8; ++i) {
        houses[i].position = getRandomPosition(gen, housePosDistFar, occupiedPositions, HOUSE_MIN_DISTANCE);
        occupiedPositions.push_back(houses[i].position);
        
        houses[i].scale = glm::vec3(scaleDist(gen));
        houses[i].rotation = rotDist(gen);
        houses[i].color1 = wallColors[i];
        houses[i].color2 = roofColors[i];
        houses[i].type = availableHouseTypes[houseTypeIndexDist(gen)];
        houses[i].collisionRadius = 4.0f * houses[i].scale.x;
    }
    
    // Create tree instances (keeping your exact logic)
    trees.resize(12);
    vector<glm::vec3> leafColors = {
        {0.0f, 0.6f, 0.0f},   // Dark green
        {0.1f, 0.7f, 0.1f},   // Medium green
        {0.2f, 0.8f, 0.1f},   // Bright green
        {0.0f, 0.5f, 0.2f},   // Forest green
        {0.1f, 0.6f, 0.0f},   // Pine green
        {0.0f, 0.7f, 0.2f},   // Spring green
        {0.2f, 0.6f, 0.0f},   // Olive green
        {0.0f, 0.8f, 0.1f},   // Lime green
        {0.1f, 0.5f, 0.1f},   // Deep forest
        {0.3f, 0.7f, 0.2f},   // Light green
        {0.0f, 0.6f, 0.3f},   // Emerald
        {0.2f, 0.5f, 0.0f}    // Army green
    };
    
    for (int i = 0; i < 12; ++i) {
        trees[i].position = getRandomPosition(gen, treePosDistMed, occupiedPositions, TREE_MIN_DISTANCE);
        occupiedPositions.push_back(trees[i].position);
        
        float heightScale = scaleDist(gen);
        float foliageScale = uniform_real_distribution<float>(0.7f, 1.2f)(gen);
        trees[i].scale = glm::vec3(heightScale, heightScale, foliageScale);
        trees[i].rotation = rotDist(gen);
        trees[i].color1 = glm::vec3(0.4f, 0.25f, 0.1f); // Trunk color
        trees[i].color2 = leafColors[i % leafColors.size()];
        trees[i].type = 0;
        trees[i].collisionRadius = 2.5f * trees[i].scale.x;
    }
    
    // Create target instances (keeping exact logic)
    targets.resize(15);
    for (int i = 0; i < 15; ++i) {
        targets[i].position = getRandomPosition(gen, targetPosDistNear, occupiedPositions, TARGET_MIN_DISTANCE);
        occupiedPositions.push_back(targets[i].position);
        
        targets[i].scale = glm::vec3(uniform_real_distribution<float>(0.9f, 1.1f)(gen));
        targets[i].rotation = rotDist(gen);
        targets[i].color1 = glm::vec3(1.0f);
        targets[i].color2 = glm::vec3(1.0f);
        targets[i].type = 0;
        targets[i].collisionRadius = 1.2f * targets[i].scale.x;
    }

    // Set camera to a safe spawn position
    camera.Position = findSafeSpawnPosition();

    // Print scene info with NEW controls
    cout << "\n=== HW4 - Three View Modes Scene ===" << endl;
    cout << "Generated a vibrant town with:" << endl;
    cout << "- " << houses.size() << " houses (spacious neighborhoods) ðŸ " << endl;
    cout << "- " << trees.size() << " trees (forest clusters) ðŸŒ²" << endl;
    cout << "- " << targets.size() << " targets (treasure hunt!) ðŸŽ¯" << endl;
    cout << "\nControls:" << endl;
    cout << "- M: Switch view modes (Orthogonal -> Perspective -> First Person)" << endl;
    cout << "- Arrow Keys: Rotate overhead views / Move in first person" << endl;
    cout << "- WASD: Move in first person mode" << endl;
    cout << "- Mouse: Look around in first person mode" << endl;
    cout << "- ESC: Exit" << endl;
    cout << "\nStarting in Orthogonal Overhead view mode" << endl;

    // Main render loop (runs until the window is closed)
    while (!glfwWindowShouldClose(window)) {
        // Compute deltaTime (time between frames) for smooth movement
        float currentFrame = glfwGetTime();
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        // Handle keyboard inputs to move the camera
        processInput(window);

        // Clear the screen each frame (color + depth)
        glClearColor(0.5f, 0.7f, 1.0f, 1.0f); // Sky blue
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // Use the shader program for the draws below
        shader.use();

        // NEW: Set projection and view based on current mode
        glm::mat4 projection = getProjectionMatrix(currentViewMode);
        glm::mat4 view = getViewMatrix(currentViewMode);
        
        shader.setMat4("projection", projection);
        shader.setMat4("view", view);

        // Draw ground (model is identity since it's already at origin)
        shader.setMat4("model", glm::mat4(1.0f));
        landMesh.Draw();

        // Draw houses (keeping your exact rendering logic)
        for (const auto& house : houses) {
            glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, house.position);
            model = glm::rotate(model, glm::radians(house.rotation), glm::vec3(0.0f, 1.0f, 0.0f));
            model = glm::scale(model, house.scale);
            shader.setMat4("model", model);
            
            // Choose the house mesh based on type (keeping your lambda)
            Mesh houseMesh = [&]() -> Mesh {
                switch (house.type) {
                    case 1:
                        return createHouse1(house.color1, house.color2);
                    case 2:
                        return createHouse2(house.color1, house.color2);
                    case 3:
                        return createHouse3(house.color1, house.color2);
                    default:
                        return Mesh(std::vector<Vertex>(), std::vector<unsigned int>());
                }
            }();
            
            houseMesh.Draw();
        }

        // Draw trees (keeping your exact logic)
        for (const auto& tree : trees) {
            glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, tree.position);
            model = glm::rotate(model, glm::radians(tree.rotation), glm::vec3(0.0f, 1.0f, 0.0f));
            model = glm::scale(model, tree.scale);
            shader.setMat4("model", model);
            
            Mesh treeMesh = createTreeVariant(tree.scale.x, tree.scale.z, tree.color2);
            treeMesh.Draw();
        }

        // Draw targets (keeping your exact logic)
        for (const auto& target : targets) {
            glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, target.position);
            model = glm::rotate(model, glm::radians(target.rotation), glm::vec3(0.0f, 1.0f, 0.0f));
            model = glm::scale(model, target.scale);
            shader.setMat4("model", model);
            
            Mesh targetMesh = createTarget();
            targetMesh.Draw();
        }

        // Show the rendered frame and process OS events
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}

// Written by Megha
// Key callback for mode switching (will be removing further into the project)
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    (void)scancode; (void)mods; // Unused parameters
    
    if (key == GLFW_KEY_M && action == GLFW_PRESS && !mKeyPressed) {
        mKeyPressed = true;
        
        // Cycle through the three modes
        currentViewMode = (ViewMode)((currentViewMode + 1) % 3);
        
        switch(currentViewMode) {
            case ORTHOGONAL_OVERHEAD:
                cout << "Switched to: Orthogonal Overhead View" << endl;
                glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
                break;
            case PERSPECTIVE_OVERHEAD:
                cout << "Switched to: Perspective Overhead View" << endl;
                glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
                break;
            case FIRST_PERSON:
                cout << "Switched to: First Person View" << endl;
                glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
                firstMouse = true; // Reset mouse for smooth transition
                break;
        }
    }
    
    if (key == GLFW_KEY_M && action == GLFW_RELEASE) {
        mKeyPressed = false;
    }
}

// Written by Megha
// Get projection matrix based on view mode
glm::mat4 getProjectionMatrix(ViewMode mode) {
    float aspect = (float)SCR_WIDTH / (float)SCR_HEIGHT;
    
    switch(mode) {
        case ORTHOGONAL_OVERHEAD:
            // Orthogonal projection - shows entire scene
            // Expand bounds to cover full scene (SCENE_SIZE = 120.0f) with generous padding
            {
                float orthoSize = SCENE_SIZE / 2.0f + 20.0f; // 80.0f total (scene is -60 to +60 with extra padding)
                float orthoHeight = orthoSize / aspect;
                return glm::ortho(-orthoSize, orthoSize, -orthoHeight, orthoHeight, 0.1f, 250.0f);
            }
            
        case PERSPECTIVE_OVERHEAD:
            // Wider field of view for perspective overhead to capture more of the scene
            return glm::perspective(glm::radians(60.0f), aspect, 0.1f, 300.0f);
            
        case FIRST_PERSON:
            // Perspective projection using camera's zoom for first person
            return glm::perspective(glm::radians(camera.Zoom), aspect, 0.1f, 100.0f);
    }
    return glm::mat4(1.0f);
}

// Written by Megha
// Get view matrix based on view mode
glm::mat4 getViewMatrix(ViewMode mode) {
    switch(mode) {
        case ORTHOGONAL_OVERHEAD:
        case PERSPECTIVE_OVERHEAD:
            // Both overhead views use rotatable camera
            updateOverheadCamera();
            return glm::lookAt(overheadPosition, sceneCenter, glm::vec3(0.0f, 1.0f, 0.0f));
            
        case FIRST_PERSON:
            // Use the existing camera system
            return camera.GetViewMatrix();
    }
    return glm::mat4(1.0f);
}

// Written by Megha
// Update overhead camera position based on rotation
void updateOverheadCamera() {
    float x = overheadDistance * sin(glm::radians(overheadRotationAngle));
    float z = overheadDistance * cos(glm::radians(overheadRotationAngle));
    overheadPosition = glm::vec3(x, 120.0f, z); // Even higher Y position for complete view
}

void processInput(GLFWwindow *window) {
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);

    // Handle input based on current view mode
    if (currentViewMode == FIRST_PERSON) {
        // First person controls (keeping your exact logic)
        glm::vec3 oldPosition = camera.Position;

        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS || glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS) {
            camera.ProcessKeyboard(FORWARD, deltaTime);
            if (checkAllCollisions(camera.Position)) {
                camera.Position = oldPosition;
            }
        }
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS || glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS) {
            camera.ProcessKeyboard(BACKWARD, deltaTime);
            if (checkAllCollisions(camera.Position)) {
                camera.Position = oldPosition;
            }
        }
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS || glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS) {
            camera.ProcessKeyboard(LEFT, deltaTime);
            if (checkAllCollisions(camera.Position)) {
                camera.Position = oldPosition;
            }
        }
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS || glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS) {
            camera.ProcessKeyboard(RIGHT, deltaTime);
            if (checkAllCollisions(camera.Position)) {
                camera.Position = oldPosition;
            }
        }
        if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS) {
            camera.ProcessKeyboard(UP, deltaTime);
        }
        if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS) {
            camera.ProcessKeyboard(DOWN, deltaTime);
        }
    } else {
        // Overhead view controls - rotate around scene with arrow keys
        float rotationSpeed = 60.0f; // degrees per second
        
        if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS) {
            overheadRotationAngle -= rotationSpeed * deltaTime;
        }
        if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS) {
            overheadRotationAngle += rotationSpeed * deltaTime;
        }
        if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS) {
            overheadDistance = max(50.0f, overheadDistance - 50.0f * deltaTime);
        }
        if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS) {
            overheadDistance = min(150.0f, overheadDistance + 50.0f * deltaTime);
        }
    }
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
    (void)window; // Unused parameter
    // Update the OpenGL viewport so rendering matches the new window size
    glViewport(0, 0, width, height);
}

// Standard Boilerplate mouse callback
void mouse_callback(GLFWwindow* window, double xpos, double ypos) {
    (void)window; // Unused parameter
    
    // Only process mouse in first person mode
    if (currentViewMode != FIRST_PERSON) return;
    
    if (firstMouse) {
        lastX = xpos;
        lastY = ypos;
        firstMouse = false;
    }

    float xoffset = xpos - lastX;
    float yoffset = lastY - ypos;
    lastX = xpos;
    lastY = ypos;

    // Pass mouse movement offsets to the camera to look around
    camera.ProcessMouseMovement(xoffset, yoffset);
}

// Keeping all your existing helper functions exactly as they were
bool isPositionValid(glm::vec3 pos, const vector<glm::vec3>& existingPositions, float minDistance) {
    for (const auto& existing : existingPositions) {
        if (glm::distance(pos, existing) < minDistance) {
            return false;
        }
    }
    return true;
}


// AI Generated with slight modifications
glm::vec3 getRandomPosition(mt19937& gen, uniform_real_distribution<float>& dist,const vector<glm::vec3>& existingPositions, float minDistance) {
    glm::vec3 pos;
    int attempts = 0;
    do {
        pos = glm::vec3(dist(gen), 0.0f, dist(gen));
        attempts++;
        if (attempts > 100) {
            uniform_real_distribution<float> expandedDist(-SCENE_SIZE/2, SCENE_SIZE/2);
            pos = glm::vec3(expandedDist(gen), 0.0f, expandedDist(gen));
            break;
        }
    } while (!isPositionValid(pos, existingPositions, minDistance));
    return pos;
}

// Written by Megha
bool checkCollision(glm::vec3 newPos, glm::vec3 objPos, float radius) {
    float distance = sqrt((newPos.x - objPos.x) * (newPos.x - objPos.x) + 
                         (newPos.z - objPos.z) * (newPos.z - objPos.z));
    return distance < radius;
}
// Written by Megha
bool checkAllCollisions(glm::vec3 newPos) {
    for (const auto& house : houses) {
        if (checkCollision(newPos, house.position, house.collisionRadius)) {
            return true;
        }
    }
    
    for (const auto& tree : trees) {
        if (checkCollision(newPos, tree.position, tree.collisionRadius)) {
            return true;
        }
    }
    
    for (const auto& target : targets) {
        if (checkCollision(newPos, target.position, target.collisionRadius)) {
            return true;
        }
    }
    
    if (abs(newPos.x) > SCENE_SIZE/2 || abs(newPos.z) > SCENE_SIZE/2) {
        return true;
    }
    
    return false;
}

// AI Generated with slight modifications by adding edge positions and Collision checks
glm::vec3 findSafeSpawnPosition() {
    vector<glm::vec3> edgePositions = {
        {-SCENE_SIZE/2 + 2, 1.8f, 0},
        {SCENE_SIZE/2 - 2, 1.8f, 0},
        {0, 1.8f, -SCENE_SIZE/2 + 2},
        {0, 1.8f, SCENE_SIZE/2 - 2},
        {-SCENE_SIZE/2 + 2, 1.8f, -SCENE_SIZE/2 + 2},
        {SCENE_SIZE/2 - 2, 1.8f, -SCENE_SIZE/2 + 2},
        {-SCENE_SIZE/2 + 2, 1.8f, SCENE_SIZE/2 - 2},
        {SCENE_SIZE/2 - 2, 1.8f, SCENE_SIZE/2 - 2}
    };
    
    for (const auto& pos : edgePositions) {
        if (!checkAllCollisions(pos)) {
            return pos;
        }
    }
    
    return glm::vec3(0, 1.8f, -SCENE_SIZE/2 + 1);
}